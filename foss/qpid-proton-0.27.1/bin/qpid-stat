#!/awips2/python/bin/python3

#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

import os
import getopt
import sys
import locale
import socket
import re
import http.client
import json
import time
import traceback
from datetime import datetime
from disp import Display, Header, Sorter
import ssl
import os.path

_host = "localhost"
_vhost = None
_connTimeout = 10
_types = ""
_limit = 250
_increasing = False
_sortcol = None

_use_ssl = None
_ssl_cert = None
_ssl_root_cert = None
_ssl_key = None

pattern = re.compile("^\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+$")

def Usage ():
    print("Usage:  qpid-stat [OPTIONS] [broker-addr]")
    print()
    print("             broker-addr is in the form:   [username/password@] hostname | ip-address [:<port>]")
    print("             ex:  localhost, 10.1.1.7:10000, broker-host:10000, guest/guest@localhost")
    print()
    print("Connection Options:")
    print("    --timeout seconds (10)  Maximum time to wait for broker connection")
    print("    --vhost VHOST_NAME (edex)  QPID virtual host to query")
    print("    --ssl enable ssl")
    print("    --nossl disable ssl")
    print("    --ssl-certificate location of the client certificate file")
    print("    --ssl-key location of the client key file")
    print("    --ssl-root-certificate location of the certificate file to use to verify the server")
    print()
    print("Display Options:")
    print()
    print("     -b   Show Brokers")
    print("     -c   Show Connections")
    print("     -s   Show Sessions")
    print("     -e   Show Exchanges")
    print("     -q   Show Queues")
    print()
    print("     -S [--sort-by] COLNAME  Sort by column name")
    print("     -I [--increasing]       Sort by increasing value; only valid when sorting (default = decreasing)")
    print("     -L [--limit] NUM        Limit output to NUM rows; only valid when sorting (default = 250)")
    print()
    sys.exit (1)

class DisplayManager():

    def displayBroker(self, jsonObjArray):
        disp = Display(prefix="  ")
        heads = []
        heads.append(Header('broker'))
        heads.append(Header('conn', Header.KMG))
        heads.append(Header('exch', Header.KMG))
        heads.append(Header('queue', Header.KMG))
        rows = []
        for staticDict in jsonObjArray:
            row = []
            row.append(staticDict.get("name"))
            statistics = staticDict.get("statistics")
            _connectionCount = statistics.get("connectionCount")
            _exchangeCount = statistics.get("exchangeCount")
            _queueCount = statistics.get("queueCount")
            row.append(_connectionCount)
            row.append(_exchangeCount)
            row.append(_queueCount)
            rows.append(row)
        title = "Brokers"
        if _sortcol:
            sorter = Sorter(heads, rows, _sortcol, _limit, _increasing)
            dispRows = sorter.getSorted()
        else:
            dispRows = rows
        disp.formattedTable(title, heads, dispRows)

    def displayConn(self, jsonObjArray):
        disp = Display(prefix="  ")
        heads = []
        heads.append(Header('client-addr'))
        heads.append(Header('client-version'))
        heads.append(Header('clientId'))
        heads.append(Header('auth'))
        heads.append(Header('last-i/o'))
        heads.append(Header('msgIn', Header.KMG))
        heads.append(Header('msgOut', Header.KMG))
        rows = []
        for staticDict in jsonObjArray:
            row = []
            row.append(staticDict.get("remoteAddress"))
            row.append(staticDict.get("clientVersion"))
            row.append(staticDict.get("clientId"))
            row.append(staticDict.get("principal"))
            statistics = staticDict.get("statistics")
            lastIOTime = time.gmtime(int(statistics.get("lastIoTime")) // 1000)
            row.append(time.strftime('%m/%d/%y %H:%M:%S', lastIOTime))
            row.append(statistics.get("messagesIn"))
            row.append(statistics.get("messagesOut"))
            rows.append(row)
        title = "Connections"
        if _sortcol:
            sorter = Sorter(heads, rows, _sortcol, _limit, _increasing)
            dispRows = sorter.getSorted()
        else:
            dispRows = rows
        disp.formattedTable(title, heads, dispRows)

    def displaySession(self, jsonObjArray):
        disp = Display(prefix="  ")
        heads = []
        heads.append(Header('id'))
        heads.append(Header('name'))
        heads.append(Header('consumers'))
        heads.append(Header('unack-msg', Header.KMG))
        rows = []
        for staticDict in jsonObjArray:
            row = []
            row.append(staticDict.get("id"))
            row.append(staticDict.get("name"))
            statistics = staticDict.get("statistics")
            row.append(statistics.get("consumerCount"))
            row.append(statistics.get("unacknowledgedMessages"))
            rows.append(row)
        title = "Sessions"
        if _sortcol:
            sorter = Sorter(heads, rows, _sortcol, _limit, _increasing)
            dispRows = sorter.getSorted()
        else:
            dispRows = rows
        disp.formattedTable(title, heads, dispRows)

    def displayExchange(self, jsonObjArray):
        disp = Display(prefix="  ")
        heads = []
        heads.append(Header("exchange"))
        heads.append(Header("type"))
        heads.append(Header("dur", Header.Y))
        heads.append(Header("bind", Header.KMG))
        heads.append(Header("msgIn", Header.KMG))
        heads.append(Header("msgDrop", Header.KMG))
        heads.append(Header("byteIn", Header.KMG))
        heads.append(Header("byteDrop", Header.KMG))
        rows = []
        for staticDict in jsonObjArray:
            row = []
            row.append(staticDict.get("name"))
            row.append(staticDict.get("type"))
            row.append(staticDict.get("durable"))
            statistics = staticDict.get("statistics")
            row.append(statistics.get("bindingCount"))
            row.append(statistics.get("messagesIn"))
            row.append(statistics.get("messagesDropped"))
            row.append(statistics.get("bytesIn"))
            row.append(statistics.get("bytesDropped"))
            rows.append(row)
        title = "Exchanges"
        if _sortcol:
            sorter = Sorter(heads, rows, _sortcol, _limit, _increasing)
            dispRows = sorter.getSorted()
        else:
            dispRows = rows
        disp.formattedTable(title, heads, dispRows)

    def displayQueue(self, jsonObjArray):
        disp = Display(prefix="  ")
        heads = []
        heads.append(Header("queue"))
        heads.append(Header("topic"))
        heads.append(Header("dur", Header.Y))
        heads.append(Header("excl", Header.Y))
        heads.append(Header("msg", Header.KMG))
        heads.append(Header("msgIn", Header.KMG))
        heads.append(Header("msgOut", Header.KMG))
        heads.append(Header("bytes", Header.KMG))
        heads.append(Header("bytesIn", Header.KMG))
        heads.append(Header("bytesOut", Header.KMG))
        heads.append(Header("cons", Header.KMG))
        heads.append(Header("bind", Header.KMG))
        rows = []
        for staticDict in jsonObjArray:
            row = []
            row.append(staticDict.get("name"))
            # Default topic to empty string to allow sorting on topic name
            row.append(staticDict.get("topic", ""))
            row.append(staticDict.get("durable"))
            row.append(staticDict.get("exclusive"))
            statistics = staticDict.get("statistics")
            row.append(statistics.get("queueDepthMessages"))
            row.append(statistics.get("totalEnqueuedMessages"))
            row.append(statistics.get("totalDequeuedMessages"))
            row.append(statistics.get("queueDepthBytes"))
            row.append(statistics.get("totalEnqueuedBytes"))
            row.append(statistics.get("totalDequeuedBytes"))
            row.append(statistics.get("consumerCount"))
            row.append(statistics.get("bindingCount"))
            rows.append(row)
        title = "Queues"
        if _sortcol:
            sorter = Sorter(heads, rows, _sortcol, _limit, _increasing)
            dispRows = sorter.getSorted()
        else:
            dispRows = rows
        disp.formattedTable(title, heads, dispRows)

    def displayMain(self, main, jsonObject):
        if   main == 'b': self.displayBroker(jsonObject)
        elif main == 'c': self.displayConn(jsonObject)
        elif main == 's': self.displaySession(jsonObject)
        elif main == 'e': self.displayExchange(jsonObject)
        elif main == 'q': self.displayQueue(jsonObject)

class RestManager():
    def __init__(self):
        self._host = None
        self._port = 0
        self._vhost = "edex"
        self._use_ssl = None
        self._certfile = None
        self._keyfile = None
        self._cafile = None

    def setPort(self, port):
        self._port = port

    def setHost(self, host):
        self._host = host

    def setVHost(self, vhost):
        self._vhost = vhost

    def setUseSsl(self, use_ssl):
        self._use_ssl = use_ssl
    
    def setCertFile(self, certfile):
        self._certfile = certfile
    
    def setKeyFile(self, keyfile):
        self._keyfile = keyfile
    
    def setCaFile(self, cafile):
        self._cafile = cafile
    
    def getCertDB(self):
        if "QPID_SSL_CERT_DB" in os.environ:
            return os.environ["QPID_SSL_CERT_DB"]
        else:
            return os.path.expanduser("~/.qpid/")

    def getCertName(self):
        if "QPID_SSL_CERT_NAME" in os.environ:
            return os.environ["QPID_SSL_CERT_NAME"]
        else:
            return "client"

    def execute(self, service):
        if self._use_ssl is None:
            certfile = os.path.join(self.getCertDB(), self.getCertName() + ".crt")
            self._use_ssl = os.path.exists(certfile)
        if self._use_ssl:
            if self._cafile is None:
                cafile = os.path.join(self.getCertDB(), "root.crt")
                if os.path.exists(cafile):
                   self._cafile = cafile
            if self._certfile is None:
                certfile = os.path.join(self.getCertDB(), self.getCertName() + ".crt")
                if os.path.exists(certfile):
                   self._certfile = certfile
            if self._keyfile is None:
                keyfile = os.path.join(self.getCertDB(), self.getCertName() + ".key")
                if os.path.exists(keyfile):
                   self._keyfile = keyfile
        if self._port is None:
            self._port = 8180

        if  self._use_ssl:
            httpConn = http.client.HTTPSConnection(self._host)
            context = ssl.create_default_context()
            if self._cafile:
                context.load_verify_locations(self._cafile)
            if self._certfile:
                context.load_cert_chain(self._certfile, self._keyfile)
            httpConn = http.client.HTTPSConnection(self._host, self._port, context=context)
        else:
            httpConn = http.client.HTTPConnection(self._host, self._port)

        if (_connTimeout is not None):
            httpConn.timeout = _connTimeout

        httpConn.connect()
        httpConn.request("GET", f"/api/latest/{service}/{self._vhost}/")
        response = httpConn.getresponse()
        
        if (response.status != 200):
            print("Unable to post request to server!")
            print(response.reason)
            sys.exit(1)
    
        return response

##
## Main Program
##

try:
    longOpts = ("top", "numeric", "sort-by=", "limit=", "increasing", "timeout=", 
                "vhost=", "ssl", "nossl", "ssl-root-certificate=", "ssl-certificate=", 
                "ssl-key=")
    (optlist, encArgs) = getopt.gnu_getopt(sys.argv[1:], "bceqsS:L:I", longOpts)
except:
    Usage()

try:
    encoding = locale.getpreferredencoding()
    cargs = [a.decode(encoding) for a in encArgs]
except:
    cargs = encArgs

for opt in optlist:
    if opt[0] == "--timeout":
        _connTimeout = int(opt[1])
        if _connTimeout == 0:
            _connTimeout = None
    elif opt[0] == "--vhost":
        new_vhost = str(opt[1]).strip()
        if new_vhost:
            _vhost = new_vhost
    elif opt[0] == "-n" or opt[0] == "--numeric":
        _numeric = True
    elif opt[0] == "-S" or opt[0] == "--sort-by":
        _sortcol = opt[1]
    elif opt[0] == "-I" or opt[0] == "--increasing":
        _increasing = True
    elif opt[0] == "-L" or opt[0] == "--limit":
        _limit = int(opt[1])
    elif opt[0] == "--ssl":
        _use_ssl = True
    elif opt[0] == "--nossl":
        _use_ssl = False
    elif opt[0] == "--ssl-root-certificate":
        _ssl_root_cert = opt[1]
        _use_ssl = True
    elif opt[0] == "--ssl-certificate":
        _ssl_cert = opt[1]
        _use_ssl = True
    elif opt[0] == "--ssl-key":
        _ssl_key = opt[1]
        _use_ssl = True
    elif len(opt[0]) == 2:
        char = opt[0][1]
        if "bcseqs".find(char) != -1:
            _types += char
        else:
            Usage()
    else:
        Usage()

if len(_types) == 0:
    Usage()

nargs = len(cargs)
rm    = RestManager()
_user = None
_password = None
_port = None

if nargs == 1:
    _broker_addr = cargs[0]
    _host = _broker_addr
    
    # check for username
    if _host.find("@") != -1:
        tokens = _host.split("@")
        _user = tokens[0]
        _host = tokens[1]
        # check for password
        if _user.find("/") != -1:
            tokens = _user.split("/")
            _user = tokens[0]
            _password = tokens[1]
    # check for port
    if _host.find(":") != -1:
        tokens = _host.split(":")
        _host = tokens[0]
        _port = int(tokens[1])

try:
    rm.setHost(_host)
    rm.setPort(_port)
    if _vhost:
        rm.setVHost(_vhost)
    if _use_ssl is not None:
        rm.setUseSsl(_use_ssl)
        rm.setCertFile(_ssl_cert)
        rm.setKeyFile(_ssl_key)
        rm.setCaFile(_ssl_root_cert)
    # determine which REST service we will be utilizing
    _serviceEndpoint = None
    if   _types[0] == 'b': _serviceEndpoint = "virtualhost"
    elif _types[0] == 'c': _serviceEndpoint = "connection"
    elif _types[0] == 's': _serviceEndpoint = "session"
    elif _types[0] == 'e': _serviceEndpoint = "exchange"
    elif _types[0] == 'q': _serviceEndpoint = "queue"
    
    response = rm.execute(_serviceEndpoint)


    
    # evaluate the JSON
    jsonStr = response.read()
    jsonObjArray = json.loads(jsonStr)
    
    if _serviceEndpoint == 'queue':
        # match topic names to queues
        exchangeResponse = rm.execute('exchange')
        exchangeJson = exchangeResponse.read()
        exchangeArray = json.loads(exchangeJson)
        [topics] = [item for item in exchangeArray if item['name'] == 'amq.topic']
        for queue in jsonObjArray:
            for binding in topics['bindings']:
                if queue['name'] == binding['destination']:
                    queue['topic'] = binding['bindingKey']

    # display construct
    dm    = DisplayManager()
    dm.displayMain(_types[0], jsonObjArray)
    
except KeyboardInterrupt:
    print()
except Exception as e:
    print("Failed: %s - %s" % (e.__class__.__name__, e))
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)
