#!/bin/bash
#
# qpidd  This shell script takes care of starting and stopping
#                the AWIPS qpid instance.
#
# chkconfig: - 99 10
# description: Qpid messaging broker used by the AWIPS 2 instance
# processname: qpid-server
# config: /awips2/qpid/etc/config.json


# Source function library.
. /etc/rc.d/init.d/functions

# Source networking configuration.
. /etc/sysconfig/network

# Check that networking is up.
[ "${NETWORKING}" == "no" ] && exit 0

RETVAL=0
prog="qpid-wrapper"

# Who to run QPID as, usually "awips".  (NOT "root")
QPIDUSER=awips

# Todays date in format of YYYYMMDD.
TODAY=`/bin/date +%Y%m%d`

QPID_HOME=/awips2/qpid
QPID_LOGDIR=${QPID_HOME}/log
LOG_PREFIX=start-qpid
YAJSW_HOME=/awips2/yajsw
wrapper_process="org.rzo.yajsw.app.WrapperJVMMain"
_wrapper_jar=${YAJSW_HOME}/wrapper.jar
pidfile=${QPID_HOME}/bin/qpid-server.pid

source /etc/watchdog.d/utilities/watchdogutils.sh

getQpidAndWrapperPids() {
   # include QPID_HOME for wes2bridge
   _qpid_pid=`pgrep -f -u ${QPIDUSER} "java -DPNAME=QPBRKR -DQPID_HOME=${QPID_HOME} "`
   if [ "$_qpid_pid" != "" ]; then
      # occasionally will get more than one running, grab parent for first one only
      _qpid_pid="${_qpid_pid%% *}"

      # grab wrapper pid from qpid process, run through awk to throw away leading white space
      _wrapper_pid=`ps --no-headers -p $_qpid_pid -o ppid | awk '{print $1}'`
   else
      # qpid not up, double check wrapper pid file
      if [ -f $pidfile ]; then
         _wrapper_pid=`cat $pidfile`
         if [ "$_wrapper_pid" != "" ]; then
            # double check process is indeed a wrapper process
            check=`ps -p $_wrapper_pid -o pid,args | grep -c wrapper.conf`
            if [ $check -eq 0 ]; then
               _wrapper_pid=""
            fi
         fi
      else
         _wrapper_pid=""
      fi
   fi
}

start() {
   getQpidAndWrapperPids
   if [ "$_wrapper_pid" != "" -o "$_qpid_pid" != "" ]; then
      echo "WARNING: Qpid already running, not starting another instance"
      return 1
   fi

   remove_watchdog_bypass "qpidd"

   local LOG="${QPID_LOGDIR}/${LOG_PREFIX}-$TODAY.log"
   local TIME=`/bin/date "+%F %T"`
   echo "$TIME: Service qpidd Starting Qpid" >> $LOG
   chmod a+r $LOG

   local DAEMON="${QPID_HOME}/bin/${prog} -noConsole"

   su - $QPIDUSER -c "$DAEMON" >> $LOG 2>&1 &

   sleep 10

   if [ -f $pidfile ]; then
      pid=`cat ${pidfile}`
      if [ "$pid" == "" ]; then
         echo "WARNING: No Wrapper Pid File Found, Qpid did not start properly"
      else
         checkStatus
      fi
   else
      echo "WARNING: No Wrapper Pid File Found, Qpid did not start properly"
   fi
}

stop() {
   bypass_watchdog "qpidd"

   # get the qpid pid
   getQpidAndWrapperPids
   if [ "$_wrapper_pid" == "" -a "$_qpid_pid" == "" ]; then
      echo "WARNING: Qpid not running, not shutdown attempted"
      return 1
   fi

   local LOG="${QPID_LOGDIR}/${LOG_PREFIX}-$TODAY.log"
   local TIME=`/bin/date "+%F %T"`
   echo "$TIME: Service qpidd Stopping Qpid" >> $LOG
   chmod a+r $LOG

   if [ "$_wrapper_pid" != "" -a "$_wrapper_pid" != "1" ]; then
      kill $_wrapper_pid
   else
      # occasionally wrapper dies and camel process is still running
      kill $_qpid_pid
   fi


   cnt=0
   savepid=$_wrapper_pid
   while [ "${_wrapper_pid}${_qpid_pid}" != "" ]; do
      if [ "$_wrapper_pid" != "$savepid" ]; then
         # only display warning when other wrapper starts (not if wrapper died)
         if [ "$_wrapper_pid" != "" ]; then
            kill $_wrapper_pid
            savepid=$_wrapper_pid
         fi
      fi

      let cnt+=1
      let mod10=cnt%10

      if [ $cnt -ge 300 ]; then
         echo "Force killing Qpid"
         if [ "$_qpid_pid" != "" ]; then
            kill -9 $_qpid_pid
         fi
         if [ "$_wrapper_pid" != "" ]; then
            kill -9 $_wrapper_pid
         fi
      elif [ $mod10 -eq 0 ]; then
         echo "Waiting for Qpid to shutdown"
      fi

      sleep 1
      getQpidAndWrapperPids
   done

   # check for any orphaned wrapper processes; terminate them if they exist
   wrapper_pids=`pgrep -fu $QPIDUSER "/awips2/yajsw/wrapper.jar"`

   for parent_pid in $wrapper_pids
   do
      child_pid=`ps --no-headers --ppid $parent_pid -o pid`
      if [ "$child_pid" == "" ]; then
         echo "Terminating orphaned wrapper pid $parent_pid"
         kill $parent_pid
      fi
   done

   echo "Qpid shutdown"
}

checkStatus() {
   getQpidAndWrapperPids
   if [ "$_wrapper_pid" == "" ]; then
      echo "Qpid is not running"
   elif [ "$_wrapper_pid" == "1" ]; then
      echo "WARNING: Qpid wrapper is not running"
      echo "WARNING: Qpid is running (java PID $_qpid_pid)"
      echo "WARNING: Recommend restarting Qpid"
   else
      echo "Qpid is running (wrapper PID $_wrapper_pid)"
      echo "Qpid is running (java PID $_qpid_pid)"
   fi
}

# Verify root user
checkUser() {
   REQUIREDUSER="root"
   CURUSER=`whoami`
   if [ "$CURUSER" != "$REQUIREDUSER" ]; then
      echo "Insufficient privileges: must run script as $REQUIREDUSER"
      exit 1
   fi
}

# remove old start logs
find ${QPID_LOGDIR} -name "${LOG_PREFIX}-*.log" -mtime +30 \
    | xargs --no-run-if-empty rm

# See how we were called.
case $1 in
   start)
      checkUser
      echo "Starting Qpid"
      start
      RETVAL=$?
      ;;
   stop)
      checkUser
      echo "Stopping Qpid"
      stop
      RETVAL=$?
      ;;
   restart)
      checkUser
      echo "Stopping Qpid"
      stop

      # small sleep for wrapper lock to disappear so that we don't make .1 version of log files
      sleep 7

      echo "Starting Qpid"
      start
      RETVAL=$?
      ;;
   status)
      checkStatus
      RETVAL=$?
      ;;
   *)
      # Print help
      echo "Usage: $0 {start|stop|restart|status}" 1>&2
      exit 1
      ;;
esac

exit $RETVAL
